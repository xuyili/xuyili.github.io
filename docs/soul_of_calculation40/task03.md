# Task03 直观的排序算法和有效的排序算法

## 1 直观的排序算法时间到底浪费在哪里

### 1.1 选择排序

- 基本思路：每一次从序列中挑出一个最大值，放到序列的最后，多次扫描序列，完成排序
- 算法步骤：
    1. 从头到尾比较相邻的两个元素，小的放前面，大的放后面，最后一个一定是最大的
    2. 从头遍历到倒数第二个元素，继续将较大值放到后面，重复该过程
- 算法复杂度：$O(N^2)$

### 1.2 插入排序

- 基本思路：从后向前扫描（类似于从后向前摸牌），每一次将元素插入到相应的位置，全部元素扫描一遍，完成排序
- 算法步骤：
1. 将最后一个元素`a[N]`与`a[1]`比较，放入合适的位置，即两个元素已经排好序了
2. 将元素`a[N-1]`与前两个元素比较，并放入合适的位置，重复该过程
- 算法复杂度：$O(N^2)$

### 1.3 无用功

以选择排序为例：
- 所有元素两两比较：如果有一个元素和其中两个元素都比较过了，且介于两个元素之间，这不再需要比较这两个元素
- 位置互换：在一个逆序数组中，有很多无用的位置互换

## 2 有效的排序算法效率来自哪里

### 2.1 归并排序

- 基本思路：将已经排好序的两个序列，依次比较两个序列中的元素，将小的值放入新序列中，完成排序
- 算法复杂度：$O(N \log N)$
- 缺点：需要使用额外的存储空间保留中间结果
- 优化的计算步骤：让两个可能最小的元素进行比较即可

### 2.2 稳定性

- 稳定性特点：两个相同的元素在排序前后相对位置维持原有的次序
- 快速排序和堆排序本身不具有稳定性
- 快速排序在极端情况下，时间复杂度是$O(N^2)$

### 2.3 三种排序算法比较

|   算法   | 平均时间复杂度 | 最坏时间复杂度 | 额外空间复杂度 | 稳定性 |
| :------: | :------------: | :------------: | :------------: | :----: |
| 归并排序 | $O(N \log N)$  | $O(N \log N)$  |     $O(N)$     |   V    |
|  堆排序  | $O(N \log N)$  | $O(N \log N)$  |     $O(1)$     |   X    |
| 快速排序 | $O(N \log N)$  |    $O(N^2)$    |  $O(\log N)$   |   X    |

### 2.4 计算机科学领域的两个原则

1. 尽可能避免做大量无用功
2. 接近理论最佳算法可能有很多种，除了考虑计算时间，还需要考虑其他维度

